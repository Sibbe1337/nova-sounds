"""
Runway ML integration for enhanced video generation.
"""
import os
import time
import logging
import tempfile
from typing import Optional, Dict, Any, List
import requests

# Configure logging
logger = logging.getLogger(__name__)

class RunwayMLService:
    """Service to interact with Runway ML API for video generation."""
    
    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize the Runway ML service.
        
        Args:
            api_key: Runway ML API key. If None, uses RUNWAY_API_KEY environment variable.
        """
os.environ['RUNWAY_API_KEY'] = 'key_57357283b4aa55c5d4a8c0db8652317613c60ada603a5e8ae5da013d71c3abfd9daca973b631d26eb4e74a6c0c5216ba2cf94dd2c2f3155d71ed167f0fdf46b1'  # Added by debug script
self.api_key = api_key or os.environ.get("RUNWAY_API_KEY", "")        if not self.api_key:
            logger.warning("No Runway ML API key provided. Functionality will be limited.")
        else:
            logger.info("Runway ML API key loaded successfully")
        
        self.api_base_url = "https://api.runwayml.com/v1"
        self.api_version = "2024-11-06"  # Use the latest API version
        
        logger.debug(f"Initialized RunwayMLService with API URL: {self.api_base_url}")
    
    def _get_headers(self) -> Dict[str, str]:
        """
        Get the headers required for API requests.
        
        Returns:
            Dict containing the required headers.
        """
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "X-Runway-Version": self.api_version,
        }
        logger.debug(f"Generated API headers: {headers}")
        return headers
    
    def image_to_video(
        self, 
        image_url: str, 
        prompt_text: str, 
        duration: int = 5,
        model: str = "gen3a_turbo"
    ) -> Dict[str, Any]:
        """
        Generate a video from an image using Runway ML.
        
        Args:
            image_url: URL of the image to use as a base for the video
            prompt_text: Text prompt describing the desired video motion/content
            duration: Video duration in seconds (5 or 10)
            model: Model to use (default: gen3a_turbo)
            
        Returns:
            Dictionary containing the task information including ID
        """
        if not self.api_key:
            raise ValueError("Runway ML API key is required for video generation")
        
        # Validate duration (Runway only supports 5 or 10 seconds)
        if duration not in [5, 10]:
            logger.warning(f"Invalid duration {duration}s. Runway only supports 5 or 10 seconds. Using 5 seconds.")
            duration = 5
        
        payload = {
            "promptImage": image_url,
            "promptText": prompt_text,
            "model": model,
            "length": f"{duration}s"
        }
        
        logger.info(f"Sending image-to-video request with prompt: '{prompt_text}', duration: {duration}s")
        logger.debug(f"Full payload: {payload}")
        
        try:
            response = requests.post(
                f"{self.api_base_url}/image_to_video",
                headers=self._get_headers(),
                json=payload
            )
            
            logger.debug(f"API response status: {response.status_code}")
            logger.debug(f"API response body: {response.text[:1000]}")  # Log first 1000 chars to avoid massive logs
            
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            logger.error(f"Runway ML API error: {e}")
            logger.error(f"Response details: {e.response.text if hasattr(e, 'response') else 'No response details'}")
            raise
        except Exception as e:
            logger.error(f"Error generating video with Runway ML: {e}")
            raise
    
    def check_task_status(self, task_id: str) -> Dict[str, Any]:
        """
        Check the status of a task.
        
        Args:
            task_id: ID of the task to check
            
        Returns:
            Dictionary containing the task status and information
        """
        logger.info(f"Checking status of task: {task_id}")
        
        try:
            response = requests.get(
                f"{self.api_base_url}/tasks/{task_id}",
                headers=self._get_headers()
            )
            
            logger.debug(f"Status check response: {response.status_code}")
            logger.debug(f"Status check body: {response.text[:1000]}")  # First 1000 chars
            
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            logger.error(f"Runway ML API error checking task: {e}")
            logger.error(f"Response details: {e.response.text if hasattr(e, 'response') else 'No response details'}")
            raise
        except Exception as e:
            logger.error(f"Error checking task status: {e}")
            raise
    
    def wait_for_completion(self, task_id: str, poll_interval: int = 10, max_retries: int = 30) -> Dict[str, Any]:
        """
        Wait for a task to complete, polling at specified intervals.
        
        Args:
            task_id: ID of the task to wait for
            poll_interval: Time in seconds between status checks
            max_retries: Maximum number of retries before giving up
            
        Returns:
            Dictionary containing the completed task information
        """
        logger.info(f"Waiting for task {task_id} to complete (max {max_retries * poll_interval}s)")
        
        for attempt in range(max_retries):
            task = self.check_task_status(task_id)
            if task["status"] in ["SUCCEEDED", "FAILED"]:
                logger.info(f"Task {task_id} completed with status: {task['status']}")
                return task
            
            logger.info(f"Task {task_id} status: {task['status']} (attempt {attempt + 1}/{max_retries}). Waiting {poll_interval} seconds...")
            time.sleep(poll_interval)
        
        logger.error(f"Task {task_id} did not complete within the allotted time")
        raise TimeoutError(f"Task {task_id} did not complete within the allotted time")
    
    def download_result(self, output_url: str, output_path: str) -> str:
        """
        Download the generated video to a local file.
        
        Args:
            output_url: URL of the generated video
            output_path: Local path to save the video
            
        Returns:
            Path to the downloaded video
        """
        logger.info(f"Downloading video from {output_url} to {output_path}")
        
        try:
            response = requests.get(output_url, stream=True)
            response.raise_for_status()
            
            with open(output_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            logger.info(f"Video downloaded successfully to {output_path}")
            return output_path
        except Exception as e:
            logger.error(f"Error downloading video: {e}")
            raise
    
    def generate_video(
        self, 
        image_path: str, 
        prompt_text: str, 
        output_path: str,
        duration: int = 5
    ) -> str:
        """
        End-to-end process to generate a video from an image and save it.
        
        Args:
            image_path: Path to the local image file
            prompt_text: Text prompt describing the desired video
            output_path: Path to save the generated video
            duration: Video duration in seconds (5 or 10)
            
        Returns:
            Path to the generated video file
        """
        logger.info(f"Starting end-to-end video generation with prompt: '{prompt_text}'")
        
        # For demo purposes, we'll just simulate uploading the image to a URL
        # In production, you would upload the image to a storage service that provides a public URL
        image_url = f"file://{os.path.abspath(image_path)}"
        logger.info(f"Using image: {image_url}")
        
        # In a real implementation, you would need to upload the image to a publicly accessible URL
        # For now, we'll assume this is handled elsewhere and simulate with this warning
        logger.warning("In production: image_url should be a publicly accessible URL from a service like GCS")
        
        # Create the video generation task
        task = self.image_to_video(
            image_url=image_url,
            prompt_text=prompt_text,
            duration=duration
        )
        
        task_id = task["id"]
        logger.info(f"Created video generation task with ID: {task_id}")
        
        # Wait for the task to complete
        completed_task = self.wait_for_completion(task_id)
        
        if completed_task["status"] == "FAILED":
            error_message = completed_task.get("error", {}).get("message", "Unknown error")
            logger.error(f"Video generation failed: {error_message}")
            raise RuntimeError(f"Video generation failed: {error_message}")
        
        # Download the generated video
        output_url = completed_task["result"]["video"]
        logger.info(f"Getting video from URL: {output_url}")
        return self.download_result(output_url, output_path)


def enhance_short_with_runway(
    input_image: str,
    prompt_text: str,
    output_path: str,
    duration: int = 5,
    api_key: Optional[str] = None
) -> str:
    """
    Enhance a single image to create a short video clip using Runway ML.
    
    Args:
        input_image: Path to the input image file
        prompt_text: Text prompt describing the desired motion/transformation
        output_path: Path to save the generated video
        duration: Video duration in seconds (5 or 10)
        api_key: Optional Runway API key (uses env var if not provided)
        
    Returns:
        Path to the generated video file
    """
    try:
        # Initialize the Runway ML service
        service = RunwayMLService(api_key)
        
        # Check if API key is available
        if not service.api_key:
            logger.warning("No Runway ML API key available. Returning mock video.")
            # Create a mock video file in development mode
            with open(output_path, "w") as f:
                f.write(f"Mock Runway ML video: {prompt_text}")
            return output_path
        
        # Generate video using Runway ML
        logger.info(f"Enhancing image '{input_image}' with prompt: '{prompt_text}'")
        return service.generate_video(
            image_path=input_image,
            prompt_text=prompt_text,
            output_path=output_path,
            duration=duration
        )
    except Exception as e:
        logger.error(f"Error enhancing image with Runway ML: {e}")
        # Create a fallback video in case of error
        with open(output_path, "w") as f:
            f.write(f"Error generating video: {str(e)}")
        return output_path 