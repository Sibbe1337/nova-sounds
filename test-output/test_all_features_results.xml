<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="1" skipped="0" tests="1" time="0.053" timestamp="2025-03-21T17:18:57.241531+01:00" hostname="MacBook-Pro.local"><testcase classname="test_all_features" name="test_integrated_workflow" time="0.040"><failure message="AttributeError: 'CrossPlatformPublisher' object has no attribute 'publish_to_tiktok'">def test_integrated_workflow():
        """Test all features working together in an integrated workflow."""
        print("\n=== Testing Integrated Workflow ===\n")
    
        # Step 1: Create test videos
        print("Step 1: Creating test videos and metadata")
    
        # Reduce to just 2 test videos for faster testing
        test_videos = [
            {
                "title": "Test Video 1",
                "description": "This is the first test video for our comprehensive testing",
                "music_id": "music_123",
                "preset": "standard"
            },
            {
                "title": "Test Video 2",
                "description": "This is the second test video with different settings",
                "music_id": "music_456",
                "preset": "energetic"
            }
        ]
    
        # In a real scenario, these would be paths to actual generated videos
        video_paths = [
            "/tmp/test_video_1.mp4",
            "/tmp/test_video_2.mp4"
        ]
    
        print(f"Created {len(test_videos)} test videos with metadata")
    
        # Step 2: Generate thumbnails for videos
        print("\nStep 2: Generating thumbnails for videos")
    
        thumbnail_optimizer = get_thumbnail_optimizer()
        test_image_path = create_test_image()
    
        thumbnail_ids = []
    
        for i, video in enumerate(test_videos):
            print(f"\nGenerating thumbnails for video {i+1}: {video['title']}")
    
            # Generate thumbnail variants - reduce to just 2 variants
            try:
                variants = thumbnail_optimizer.generate_thumbnail_variants(
                    test_image_path,
                    video,
                    num_variants=2
                )
    
                if not variants:
                    print("Warning: No variants were generated. Using mock variants.")
                    # Create mock variants
                    variants = [f"/tmp/mock_variant_{j}.jpg" for j in range(2)]
    
                timestamp = int(datetime.now().timestamp())
                thumbnail_id = f"thumb_{i}_{timestamp}"
                thumbnail_ids.append(thumbnail_id)
    
                print(f"Generated {len(variants)} thumbnail variants for video {i+1}")
    
                # Simulate A/B testing for thumbnails
                for j, _ in enumerate(variants):
                    variant_id = f"variant_{j}"
                    # Different performance for different variants
                    impressions = 500 + (i * 100)
                    clicks = int(impressions * (0.05 + (j * 0.01) + (i * 0.01)))
    
                    thumbnail_optimizer.track_thumbnail_performance(
                        thumbnail_id,
                        variant_id,
                        impressions,
                        clicks
                    )
    
                    print(f"  - Tracked variant {j+1}: {impressions} impressions, {clicks} clicks ({clicks/impressions:.1%} CTR)")
    
                # Get best performing thumbnail
                results = thumbnail_optimizer.get_test_results(thumbnail_id)
    
                if results.get('winner'):
                    winner_id = results['winner'].get('variant_id')
                    winner_ctr = results['winner'].get('ctr')
                    print(f"  - Best thumbnail: {winner_id} with {winner_ctr:.2%} CTR")
                else:
                    print(f"  - No clear winner determined")
            except Exception as e:
                print(f"Error generating thumbnails: {e}")
                continue
    
        # Step 3: Schedule publishing for videos
        print("\nStep 3: Scheduling publishing for videos")
    
        scheduler = get_content_scheduler()
        publisher = get_cross_platform_publisher()
    
        # Get optimal publishing times
        platform_id = "youtube"
        days_ahead = 2  # Reduce from 3 to 2 days
        optimal_times = scheduler.get_optimal_publishing_times(platform_id, days_ahead)
    
        print(f"Found {len(optimal_times)} optimal publishing times for {platform_id.upper()}")
        for i, time in enumerate(optimal_times[:2]):  # Show only 2 times
            print(f"  - {time.strftime('%Y-%m-%d %H:%M:%S')} ({time.strftime('%A')})")
    
        # Schedule individual videos
        task_ids = []
    
        for i, (video, path) in enumerate(zip(test_videos, video_paths)):
            # Use one of the optimal times or a time in the future
            scheduled_time = optimal_times[i % len(optimal_times)] if optimal_times else datetime.now() + timedelta(hours=i+1)
    
            print(f"\nScheduling video {i+1} ({video['title']}) for {scheduled_time.strftime('%Y-%m-%d %H:%M:%S')}")
    
            # Simplify to just YouTube platform
            platforms = ["youtube"]
    
            timestamp = int(datetime.now().timestamp())
            task_id = scheduler.schedule_video_publishing(
                video_id=f"video_{i}_{timestamp}",
                platforms=platforms,
                scheduled_time=scheduled_time
            )
    
            task_ids.append(task_id)
    
            print(f"  - Scheduled as task {task_id}")
            print(f"  - Target platforms: {', '.join(platforms)}")
    
        # Step 4: Create and schedule a batch of videos
        print("\nStep 4: Creating and scheduling a batch of videos")
    
        # Create a batch with multiple videos (reduce to 3)
        batch_items = []
    
        for i in range(3):
            batch_items.append({
                "title": f"Batch Video {i+1}",
                "description": f"This is batch video {i+1} for comprehensive testing",
                "music_id": f"music_{1000 + i}",
                "preset": ["standard", "energetic", "dramatic"][i % 3]
            })
    
        batch_id = scheduler.create_batch(batch_items)
        print(f"Created batch {batch_id} with {len(batch_items)} videos")
    
        # Schedule the batch for processing
        batch_time = datetime.now() + timedelta(hours=4)
        batch_task_id = scheduler.schedule_batch_processing(batch_id, batch_time)
    
        print(f"Scheduled batch for processing at {batch_time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Batch task ID: {batch_task_id}")
    
        # Step 5: Simulate cross-platform publishing and analytics
        print("\nStep 5: Simulating cross-platform publishing and analytics")
    
        # Mock publication to get video IDs - just test YouTube and TikTok
        video_ids = {}
        platforms_to_test = [Platform.YOUTUBE, Platform.TIKTOK]
    
        for platform in platforms_to_test:
            print(f"\nSimulating publication to {platform.name}")
    
            # Mock video path
            mock_video_path = "/tmp/mock_video.mp4"
    
            # Create standard metadata
            metadata = {
                "title": f"Test Video for {platform.name}",
                "description": "This is a test video for multi-platform distribution",
                "hashtags": ["test", "multiplatform", platform.value]
            }
    
            result = None
    
            # Call the platform-specific publish method
            if platform == Platform.TIKTOK:
&gt;               result = publisher.publish_to_tiktok(mock_video_path, metadata)
E               AttributeError: 'CrossPlatformPublisher' object has no attribute 'publish_to_tiktok'

test_all_features.py:234: AttributeError</failure></testcase></testsuite></testsuites>